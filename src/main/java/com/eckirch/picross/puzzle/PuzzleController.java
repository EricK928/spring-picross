package com.eckirch.picross.puzzle;

import java.util.Optional;
import java.util.Random;
import java.util.List;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.ResponseBody;

import com.eckirch.picross.user.User;
import com.eckirch.picross.user.UserController;
import com.eckirch.picross.user.UserRepository;

import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PathVariable;

@Controller // This means that this class is a Controller
public class PuzzleController 
{
	private Puzzle tempPuzzle=null;
	
	@Autowired // This means to get the bean called userRepository// Which is auto-generated by Spring, we will use it to handle the data
	private UserRepository userRepository;
	
	@Autowired // This means to get the bean called userRepository// Which is auto-generated by Spring, we will use it to handle the data
	private PuzzleRepository puzzleRepository;
	
	@GetMapping(path="/picrossRandom")
	public String picrossForm(Model model) 
	{
		User u=UserController.getLoggedInUser();
		if(u!=null)
		{
			model.addAttribute("picrossRandom", new GameData());
		    return "picrossRandom";
		}
		else
		{
			return "redirect:login";
		}
	}
	
	/**
	 * Second part of the change admin status page to be displayed in browser, changes the admin status of the given user
	 * @param user: User data from part 1
	 * @param model: Model that will contain various data types used between methods and web pages
	 * @return: "giveAdminResult.html" if given account's admin status has been changed
	 * @return: "giveAdminNoUser.html" if user does not exist
	 */
	@PostMapping(path="/picrossRandom")
	public String picrossSubmit(@ModelAttribute GameData gd, Model model) 
	{
		int exp=1;
		
		Random r=new Random();
		
		String [] hintSplit=gd.getHintsLeft().split(" ", 3);
		int remainingHints=Integer.parseInt(hintSplit[0]);
		
		User u=UserController.getLoggedInUser();
		
		//Do calculations once able
		exp+=(11-Integer.parseInt(gd.getDifficulty()))*(remainingHints+1)*(r.nextInt(2)+1);
		u.setUserExp(u.getUserExp()+exp);
		userRepository.save(u);
		
		return "picrossCompleted";
	}
	
	@GetMapping(path="/CreateRandomPuzzle")
	public String puzzleAddition() 
	{
		//String ret="Good!";
		Puzzle p=new Puzzle();
		
		Integer idToBe=Math.abs(new Random().nextInt());
		//This is to ensure duplicate IDs don't happen
		//Implement through other data types, and below - Eric at 2:50 A.M. reminding myself when I wake up :)
		while(userRepository.findById(idToBe).isPresent()!=false)
		{
			idToBe=Math.abs(new Random().nextInt());
		}
		
		p.setId(idToBe);
		p.setCreatorId(1);
		p.setPuzzleName("Randomly Generated");
		p.setPuzzleHeight(10);
		p.setPuzzleWidth(10);
		p.setTimesCompleted(0);
		
		String data="";
		Random r=new Random();
		
		for(int i=0; i<100; i++)
		{
			if(r.nextInt()%2==0)
			{
				data+="X";
			}
			else
			{
				data+="O";
			}
		}
		p.setPuzzleData(data);
		puzzleRepository.save(p);
		return "loginFailed";
	}
	
	@GetMapping(path="/findCodePuzzle")
	public String picrossFinder(Model model) 
	{
		User u=UserController.getLoggedInUser();
		if(u!=null)
		{
			GameData gd=new GameData();
			gd.setHintsLeft("1");
			model.addAttribute("findCodePuzzle", new Puzzle());
		    return "findCodePuzzle";
		}
		else
		{
			return "redirect:login";
		}
	}
	
	@PostMapping(path="/findCodePuzzle")
	public String picrossPlayer(@ModelAttribute Puzzle p, Model model) 
	{
		Puzzle found = puzzleRepository.findByPuzzleID(Integer.parseInt(p.getPuzzleName()));
		tempPuzzle=found;
		model.addAttribute("puzzleFound", found);
		System.out.println();
		return "/picrossCode";
	}
	
	@GetMapping(path="/picrossCode")
	public String picrossCodeGame(@ModelAttribute Model model) 
	{
		User u=UserController.getLoggedInUser();
		if(u!=null)
		{
			model.addAttribute("picrossCode", new GameData());
		    return "picrossCode";
		}
		else
		{
			return "redirect:login";
		}
	}
	
	/**
	 * Second part of the change admin status page to be displayed in browser, changes the admin status of the given user
	 * @param user: User data from part 1
	 * @param model: Model that will contain various data types used between methods and web pages
	 * @return: "giveAdminResult.html" if given account's admin status has been changed
	 * @return: "giveAdminNoUser.html" if user does not exist
	 */
	@PostMapping(path="/picrossCode")
	public String picrossCodeSubmit(@ModelAttribute GameData gd, Model model) 
	{
		int exp=1;
		
		tempPuzzle.setTimesCompleted(tempPuzzle.getTimesCompleted()+1);
		User u=UserController.getLoggedInUser();
		
		int fillSpotCount=0;
		int puzzleHeight=tempPuzzle.getPuzzleHeight();
		int puzzleWidth=tempPuzzle.getPuzzleWidth();
		String puzzleData=tempPuzzle.getPuzzleData();
		
		for(int i=0; i<puzzleHeight*puzzleWidth; i++)
		{
			if(puzzleData.charAt(i)==('O'))
			{
				fillSpotCount++;
			}
		}
		
		Random r=new Random();
		int mul=r.nextInt(2)+1;
		int moreExp=(puzzleWidth+(fillSpotCount/10))*mul;
		exp+=moreExp;
		
		u.setUserExp(u.getUserExp()+exp);
		puzzleRepository.save(tempPuzzle);
		tempPuzzle=null;
		userRepository.save(u);
		
		return "picrossCompleted";
	}
	
	@GetMapping(path="/createPuzzle")
	public String picrossCreateGame(Model model) 
	{
		if(UserController.getLoggedInUser()!=null)
		{
			model.addAttribute("createPuzzle", new Puzzle());
		    return "createPuzzle";
		}
		else
		{
			return "redirect:login";
		}
	}
	
	/**
	 * Second part of the change admin status page to be displayed in browser, changes the admin status of the given user
	 * @param user: User data from part 1
	 * @param model: Model that will contain various data types used between methods and web pages
	 * @return: "giveAdminResult.html" if given account's admin status has been changed
	 * @return: "giveAdminNoUser.html" if user does not exist
	 */
	@PostMapping(path="/createPuzzle")
	public String picrossCreateSubmit(@ModelAttribute Puzzle p, Model model) 
	{
		Puzzle dat=p;
		User u=UserController.getLoggedInUser();
		
		Integer idToBe=Math.abs(new Random().nextInt());
		//This is to ensure duplicate IDs don't happen
		//Implement through other data types, and below - Eric at 2:50 A.M. reminding myself when I wake up :)
		while(userRepository.findById(idToBe).isPresent()!=false)
		{
			idToBe=Math.abs(new Random().nextInt());
		}
		
		if(dat.getPuzzleHeight()==null)
		{
			dat.setPuzzleHeight(10);//Edge case to prevent bug with size not initially loading until changed
		}
		
		if(dat.getPuzzleWidth()==null)
		{
			dat.setPuzzleWidth(10);//Edge case to prevent bug with size not initially loading until changed
		}
		
		dat.setId(idToBe);
		dat.setCreatorId(u.getId());
		dat.setTimesCompleted(0);

		puzzleRepository.save(dat);
		model.addAttribute("finishedPuzzle", dat);
		
		if(UserController.getLoggedInUser()!=null)
		{
			return "picrossCreated";
		}
		else
		{
			return "redirect:login";
		}
	}
	
	@GetMapping(path="/getUserPuzzles")
	public String userPuzzles(Model model) 
	{
		User u=UserController.getLoggedInUser();
		if(u!=null)
		{
			String puzzleName="";
			String puzzleCodes="";
			String timesCompleted="";
			
			List<Puzzle> puzzles = puzzleRepository.findByCreatorID(u.getId());
			
			for(int i=0; i<puzzles.size(); i++)
			{
				puzzleName+=puzzles.get(i).getPuzzleName();
				puzzleCodes+=puzzles.get(i).getId();
				timesCompleted+=puzzles.get(i).getTimesCompleted();
				
				if(i<puzzles.size()-1)
				{
					puzzleName+=";";
					puzzleCodes+=";";
					timesCompleted+=";";
				}
			}
			
			UserPuzzles pData=new UserPuzzles();
			
			pData.setPuzzleName(puzzleName);
			pData.setTimesCompleted(timesCompleted);
			pData.setPuzzleCodes(puzzleCodes);
			
			model.addAttribute("userData", pData);
			
		    return "getUserPuzzles";
		}
		else
		{
			return "redirect:login";
		}
	}
	

	/*@PostMapping(path="/getUserPuzzles")
	public String userPuzzlesSubmit(@ModelAttribute GameData gd, Model model) 
	{
		int exp=1;
		
		tempPuzzle.setTimesCompleted(tempPuzzle.getTimesCompleted()+1);
		User u=UserController.getLoggedInUser();
		
		int fillSpotCount=0;
		int puzzleHeight=tempPuzzle.getPuzzleHeight();
		int puzzleWidth=tempPuzzle.getPuzzleWidth();
		String puzzleData=tempPuzzle.getPuzzleData();
		
		for(int i=0; i<puzzleHeight*puzzleWidth; i++)
		{
			if(puzzleData.charAt(i)==('O'))
			{
				fillSpotCount++;
			}
		}
		
		Random r=new Random();
		int mul=r.nextInt(2)+1;
		int moreExp=(puzzleWidth+(fillSpotCount/10))*mul;
		exp+=moreExp;
		
		u.setUserExp(u.getUserExp()+exp);
		puzzleRepository.save(tempPuzzle);
		tempPuzzle=null;
		userRepository.save(u);
		
		return "picrossCompleted";
	}*/

}